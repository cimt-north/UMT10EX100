unit Exporter;

interface

uses
  System.SysUtils, Vcl.ComCtrls, Vcl.StdCtrls;

procedure ExportSplit(const IniPath: string; AProgress: TProgressBar; AMemo: TMemo = nil);

implementation

uses
  System.Classes, System.Variants, System.IOUtils,
  Winapi.ActiveX, Winapi.Windows, Winapi.Messages,
  IniFiles, ComObj, System.DateUtils,
  Vcl.Forms;

const
  COL_JOB_FIRST     = 1;
  COL_JOB_LAST      = 5;
  COL_PART_FIRST    = 6;
  COL_PART_LAST     = 9;
  COL_PROCESS_FIRST = 20;
  COL_PROCESS_LAST  = 77;

{-------------------- Helpers --------------------}

procedure MemoStep(AMemo: TMemo; const S: string);
begin
  if Assigned(AMemo) then
  begin
    AMemo.Lines.Add(FormatDateTime('hh:nn:ss', Now) + '  ' + S);
    AMemo.SelStart := Length(AMemo.Text);
    AMemo.Perform(EM_SCROLLCARET, 0, 0);
    Application.ProcessMessages;
  end;
end;

function CsvEscape(const S: string): string;
var
  NeedsQuote: Boolean;
  R: string;
begin
  NeedsQuote := (Pos(',', S) > 0) or (Pos('"', S) > 0) or
                (Pos(#13, S) > 0) or (Pos(#10, S) > 0);
  R := StringReplace(S, '"', '""', [rfReplaceAll]);
  if NeedsQuote then
    Result := '"' + R + '"'
  else
    Result := R;
end;

function CsvJoin(const Fields: TArray<string>): string;
var
  i: Integer;
begin
  Result := '';
  for i := 0 to High(Fields) do
  begin
    if i > 0 then Result := Result + ',';
    Result := Result + CsvEscape(Fields[i]);
  end;
end;

function ForceCsvName(const Path, BaseName: string): string;
var
  Dir: string;
begin
  if Path = '' then Exit('');
  Dir := ExtractFileDir(Path);
  Result := IncludeTrailingPathDelimiter(Dir) + BaseName + '.csv';
end;

{-------------------- CSV Writers --------------------}

procedure SaveCSVWithCustomHeader(const SrcSheet: OleVariant;
  FirstCol, LastCol: Integer; const Path: string;
  const Title: string; const LogPath: string;
  AProgress: TProgressBar; AMemo: TMemo;
  const HeaderFields: TArray<string>);
var
  R: Integer;
  SL: TStringList;
  Total, Done, LastRow, StartRow, EndRow, WroteDataCount: Integer;
begin
  MemoStep(AMemo, 'Start ' + Title + ' → ' + Path);
  SL := TStringList.Create;
  try
    SL.Add(CsvJoin(HeaderFields));
    LastRow := SrcSheet.UsedRange.Row + SrcSheet.UsedRange.Rows.Count - 1;
    StartRow := 3;
    EndRow := LastRow;

    if EndRow >= StartRow then
      Total := 1 + (EndRow - StartRow + 1)
    else
      Total := 1;

    Done := 0;
    if Assigned(AProgress) then
    begin
      AProgress.Position := 0;
      AProgress.Max := Total;
    end;

    Inc(Done);
    if Assigned(AProgress) then AProgress.Position := Done;

    WroteDataCount := 0;
    for R := StartRow to EndRow do
    begin
      SL.Add(CsvLineFromRow(SrcSheet, R, FirstCol, LastCol));
      Inc(WroteDataCount);
      Inc(Done);
      if Assigned(AProgress) then AProgress.Position := Done;
    end;

    ForceDirectories(ExtractFileDir(Path));
    SL.SaveToFile(Path, TEncoding.UTF8);

    TFile.AppendAllText(LogPath,
      Format('[%s] %s -> %s (header + %d rows)', [FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), Title, Path, WroteDataCount]) + sLineBreak,
      TEncoding.UTF8);

    MemoStep(AMemo, Format('%s completed (%d rows)', [Title, WroteDataCount]));
  finally
    SL.Free;
  end;
end;

{-------------------- PROCESS (Long format) --------------------}

procedure SaveProcessAsLongCSV(const SrcSheet: OleVariant;
  const Path: string; const LogPath: string; AProgress: TProgressBar; AMemo: TMemo);
var
  SL: TStringList;
  LastRow, StartRow, EndRow, Total, Done, R: Integer;
  MfgNo, PartFig, ProcName, SetVal, MaVal: string;
  FirstOnlyProcCol, TripletStartCol, TripletEndCol, MaxTriples, k: Integer;
  ProcCol, SetCol, MaCol: Integer;
begin
  MemoStep(AMemo, 'Start PROCESS (long; T uses 0/0, U..BY uses sheet set/ma) → ' + Path);
  SL := TStringList.Create;
  try
    SL.Add(CsvJoin(TArray<string>.Create('Mfg.No.','Part figure','process','set','ma')));
    LastRow := SrcSheet.UsedRange.Row + SrcSheet.UsedRange.Rows.Count - 1;
    StartRow := 3;
    EndRow := LastRow;
    FirstOnlyProcCol := COL_PROCESS_FIRST;
    TripletStartCol := COL_PROCESS_FIRST + 1;
    TripletEndCol := COL_PROCESS_LAST;

    if TripletEndCol >= TripletStartCol then
      MaxTriples := (TripletEndCol - TripletStartCol + 1) div 3
    else
      MaxTriples := 0;

    Total := 1 + (EndRow - StartRow + 1) * (1 + MaxTriples);
    Done := 0;
    if Assigned(AProgress) then
    begin
      AProgress.Position := 0;
      AProgress.Max := Total;
    end;
    Inc(Done);

    for R := StartRow to EndRow do
    begin
      MfgNo := VarToStr(SrcSheet.Cells[R, 3].Value);
      PartFig := VarToStr(SrcSheet.Cells[R, 6].Value);
      ProcName := VarToStr(SrcSheet.Cells[R, FirstOnlyProcCol].Value);
      if Trim(ProcName) <> '' then
        SL.Add(CsvJoin(TArray<string>.Create(MfgNo, PartFig, ProcName, '0', '0')));
      for k := 0 to MaxTriples - 1 do
      begin
        ProcCol := TripletStartCol + k * 3;
        SetCol := ProcCol + 1;
        MaCol := ProcCol + 2;
        ProcName := VarToStr(SrcSheet.Cells[R, ProcCol].Value);
        SetVal := VarToStr(SrcSheet.Cells[R, SetCol].Value);
        MaVal := VarToStr(SrcSheet.Cells[R, MaCol].Value);
        if Trim(SetVal) = '' then SetVal := '0';
        if Trim(MaVal) = '' then MaVal := '0';
        if Trim(ProcName) <> '' then
          SL.Add(CsvJoin(TArray<string>.Create(MfgNo, PartFig, ProcName, SetVal, MaVal)));
      end;
    end;

    ForceDirectories(ExtractFileDir(Path));
    SL.SaveToFile(Path, TEncoding.UTF8);

    MemoStep(AMemo, Format('PROCESS completed (%d data rows)', [SL.Count - 1]));
  finally
    SL.Free;
  end;
end;

{-------------------- Main --------------------}

procedure ExportSplit(const IniPath: string; AProgress: TProgressBar; AMemo: TMemo = nil);
var
  Ini: TMemIniFile;
  InputFile, SheetName: string;
  OutJob, OutPart, OutProcess, LogPath, LogDir: string;
  Excel, WB, Sheet: OleVariant;
  HeaderJob, HeaderPart: TArray<string>;
begin
  HeaderJob := TArray<string>.Create('CstmrCD','Cstmr.Name','Mfg.No.','RE','ProductName');
  HeaderPart := TArray<string>.Create('ColC','PartsName','Material','SizeRemarks','PartsQuantity');

  MemoStep(AMemo, 'Reading INI...');
  Ini := TMemIniFile.Create(IniPath, TEncoding.UTF8);
  try
    InputFile := Ini.ReadString('Input', 'File', '');
    SheetName := Ini.ReadString('Input', 'Sheet', 'Sheet1');
    OutJob := ForceCsvName(Ini.ReadString('Output1','Path',''), 'NewOrder_Job');
    OutPart := ForceCsvName(Ini.ReadString('Output2','Path',''), 'NewOrder_Part');
    OutProcess := ForceCsvName(Ini.ReadString('Output3','Path',''), 'NewOrder_Process');

    LogPath := Ini.ReadString('Options', 'LogPath', '');
    if Trim(LogPath) = '' then
    begin
      LogDir := IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0))) + 'LOG\';
      if not TDirectory.Exists(LogDir) then
        TDirectory.CreateDirectory(LogDir);
      LogPath := TPath.Combine(LogDir, 'export_log_' + FormatDateTime('yyyymmdd', Now) + '.txt');
    end;
  finally
    Ini.Free;
  end;

  if not FileExists(InputFile) then
    raise Exception.CreateFmt('Input file not found: %s', [InputFile]);

  MemoStep(AMemo, 'Opening Excel...');
  CoInitialize(nil);
  try
    Excel := CreateOleObject('Excel.Application');
    Excel.Visible := False;
    WB := Excel.Workbooks.Open(InputFile);
    try
      try
        Sheet := WB.Worksheets[SheetName];
      except
        Sheet := WB.Worksheets[1];
      end;

      if OutJob <> '' then
        SaveCSVWithCustomHeader(Sheet, COL_JOB_FIRST, COL_JOB_LAST, OutJob, 'JOB', LogPath, AProgress, AMemo, HeaderJob);
      if OutPart <> '' then
        SaveCSVWithCustomHeaderByCols(Sheet, [3,6,7,8,9], OutPart, 'PART', LogPath, AProgress, AMemo, HeaderPart);
      if OutProcess <> '' then
        SaveProcessAsLongCSV(Sheet, OutProcess, LogPath, AProgress, AMemo);

      MemoStep(AMemo, 'Export completed successfully.');
    finally
      WB.Close(False);
      Excel.Quit;
    end;
  finally
    CoUninitialize;
  end;
end;

end.

