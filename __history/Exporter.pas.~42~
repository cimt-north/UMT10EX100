unit Exporter;

interface

uses
  System.SysUtils, Vcl.ComCtrls, Vcl.StdCtrls;

procedure ExportSplit(const IniPath: string; AProgress: TProgressBar; AMemo: TMemo = nil);

implementation

uses
  System.Classes, System.Variants, System.IOUtils,
  Winapi.ActiveX, Winapi.Windows, Winapi.Messages,
  IniFiles, ComObj, System.DateUtils,
  Vcl.Forms;

const
  // Column ranges in Excel
  COL_JOB_FIRST     = 1;   // A
  COL_JOB_LAST      = 5;   // E
  COL_PART_FIRST    = 6;   // F
  COL_PART_LAST     = 9;   // I
  COL_PROCESS_FIRST = 20;  // T
  COL_PROCESS_LAST  = 77;  // BY

{-------------------- Helpers --------------------}

procedure MemoStep(AMemo: TMemo; const S: string);
begin
  if Assigned(AMemo) then
  begin
    AMemo.Lines.Add(FormatDateTime('hh:nn:ss', Now) + '  ' + S);
    AMemo.SelStart := Length(AMemo.Text);
    AMemo.Perform(EM_SCROLLCARET, 0, 0);
    Application.ProcessMessages;
  end;
end;

function CsvEscape(const S: string): string;
var
  NeedsQuote: Boolean;
  R: string;
begin
  NeedsQuote := (Pos(',', S) > 0) or (Pos('"', S) > 0) or
                (Pos(#13, S) > 0) or (Pos(#10, S) > 0);
  R := StringReplace(S, '"', '""', [rfReplaceAll]);
  if NeedsQuote then
    Result := '"' + R + '"'
  else
    Result := R;
end;

function CsvJoin(const Fields: TArray<string>): string;
var
  i: Integer;
begin
  Result := '';
  for i := 0 to High(Fields) do
  begin
    if i > 0 then Result := Result + ',';
    Result := Result + CsvEscape(Fields[i]);
  end;
end;

function ForceCsvName(const FullPath, BaseName: string): string;
var
  Dir: string;
begin
  if FullPath = '' then Exit('');
  Dir := ExtractFileDir(FullPath);
  Result := TPath.Combine(Dir, BaseName + '.csv');
end;

{-------------------- CSV Writers --------------------}

procedure SaveCSVWithCustomHeader(const SrcSheet: OleVariant;
  FirstCol, LastCol: Integer; const Path: string;
  const Title: string; const LogPath: string;
  AProgress: TProgressBar; AMemo: TMemo;
  const HeaderFields: TArray<string>);
var
  R, LastRow, StartRow, EndRow, Done, Total, WroteDataCount: Integer;
  SL: TStringList;
begin
  MemoStep(AMemo, 'Start ' + Title + ' → ' + Path);

  SL := TStringList.Create;
  try
    SL.Add(CsvJoin(HeaderFields));

    LastRow  := SrcSheet.UsedRange.Row + SrcSheet.UsedRange.Rows.Count - 1;
    StartRow := 3;
    EndRow   := LastRow;

    Total := 1 + Max(0, EndRow - StartRow + 1);
    Done := 0;

    if Assigned(AProgress) then
    begin
      AProgress.Position := 0;
      AProgress.Max := Total;
    end;

    Inc(Done);
    if Assigned(AProgress) then AProgress.Position := Done;

    WroteDataCount := 0;
    for R := StartRow to EndRow do
    begin
      SL.Add(CsvJoin([
        VarToStr(SrcSheet.Cells[R, FirstCol].Value),
        VarToStr(SrcSheet.Cells[R, FirstCol + 1].Value),
        VarToStr(SrcSheet.Cells[R, FirstCol + 2].Value),
        VarToStr(SrcSheet.Cells[R, FirstCol + 3].Value),
        VarToStr(SrcSheet.Cells[R, FirstCol + 4].Value)
      ]));
      Inc(WroteDataCount);
      Inc(Done);
      if Assigned(AProgress) then AProgress.Position := Done;
    end;

    ForceDirectories(ExtractFileDir(Path));
    SL.SaveToFile(Path, TEncoding.UTF8);

    TFile.AppendAllText(LogPath,
      Format('[%s] %s -> %s (%d rows)', [FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), Title, Path, WroteDataCount])
      + sLineBreak, TEncoding.UTF8);

    MemoStep(AMemo, Title + ' completed: ' + IntToStr(WroteDataCount) + ' rows.');
  finally
    SL.Free;
  end;
end;

procedure SaveCSVWithCustomHeaderByCols(const SrcSheet: OleVariant;
  const ColIndices: array of Integer; const Path: string;
  const Title: string; const LogPath: string;
  AProgress: TProgressBar; AMemo: TMemo;
  const HeaderFields: TArray<string>);
var
  R, i, LastRow, StartRow, EndRow, Done, Total, WroteDataCount: Integer;
  SL: TStringList;
  Values: array of string;
begin
  MemoStep(AMemo, 'Start ' + Title + ' → ' + Path);
  SL := TStringList.Create;
  try
    SL.Add(CsvJoin(HeaderFields));
    LastRow  := SrcSheet.UsedRange.Row + SrcSheet.UsedRange.Rows.Count - 1;
    StartRow := 3;
    EndRow   := LastRow;
    Total := 1 + Max(0, EndRow - StartRow + 1);
    Done := 0;
    if Assigned(AProgress) then
    begin
      AProgress.Position := 0;
      AProgress.Max := Total;
    end;

    Inc(Done);
    if Assigned(AProgress) then AProgress.Position := Done;
    WroteDataCount := 0;

    for R := StartRow to EndRow do
    begin
      SetLength(Values, Length(ColIndices));
      for i := 0 to High(ColIndices) do
        Values[i] := VarToStr(SrcSheet.Cells[R, ColIndices[i]].Value);
      SL.Add(CsvJoin(Values));
      Inc(WroteDataCount);
      Inc(Done);
      if Assigned(AProgress) then AProgress.Position := Done;
    end;

    ForceDirectories(ExtractFileDir(Path));
    SL.SaveToFile(Path, TEncoding.UTF8);
    TFile.AppendAllText(LogPath,
      Format('[%s] %s -> %s (%d rows)', [FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), Title, Path, WroteDataCount])
      + sLineBreak, TEncoding.UTF8);
    MemoStep(AMemo, Title + ' completed: ' + IntToStr(WroteDataCount) + ' rows.');
  finally
    SL.Free;
  end;
end;

procedure SaveProcessAsLongCSV(const SrcSheet: OleVariant;
  const Path: string; const LogPath: string; AProgress: TProgressBar; AMemo: TMemo);
var
  SL: TStringList;
  LastRow, StartRow, EndRow, Total, Done, R: Integer;
  MfgNo, PartFig, ProcName, SetVal, MaVal: string;
  FirstOnlyProcCol, TripletStartCol, TripletEndCol, MaxTriples, k: Integer;
  ProcCol, SetCol, MaCol: Integer;
begin
  MemoStep(AMemo, 'Start PROCESS (long format) → ' + Path);
  SL := TStringList.Create;
  try
    SL.Add(CsvJoin(TArray<string>.Create('Mfg.No.','Part figure','process','set','ma')));
    LastRow  := SrcSheet.UsedRange.Row + SrcSheet.UsedRange.Rows.Count - 1;
    StartRow := 3;
    EndRow   := LastRow;

    FirstOnlyProcCol := COL_PROCESS_FIRST;
    TripletStartCol  := COL_PROCESS_FIRST + 1;
    TripletEndCol    := COL_PROCESS_LAST;
    MaxTriples := (TripletEndCol - TripletStartCol + 1) div 3;

    Total := 1 + (EndRow - StartRow + 1) * (1 + MaxTriples);
    Done := 0;
    if Assigned(AProgress) then
    begin
      AProgress.Position := 0;
      AProgress.Max := Total;
    end;

    Inc(Done);
    if Assigned(AProgress) then AProgress.Position := Done;

    for R := StartRow to EndRow do
    begin
      MfgNo   := VarToStr(SrcSheet.Cells[R, 3].Value);
      PartFig := VarToStr(SrcSheet.Cells[R, 6].Value);
      ProcName := VarToStr(SrcSheet.Cells[R, FirstOnlyProcCol].Value);
      if Trim(ProcName) <> '' then
        SL.Add(CsvJoin(TArray<string>.Create(MfgNo, PartFig, ProcName, '0', '0')));
      Inc(Done);

      for k := 0 to MaxTriples - 1 do
      begin
        ProcCol := TripletStartCol + k * 3;
        SetCol  := ProcCol + 1;
        MaCol   := ProcCol + 2;
        ProcName := VarToStr(SrcSheet.Cells[R, ProcCol].Value);
        SetVal   := VarToStr(SrcSheet.Cells[R, SetCol].Value);
        MaVal    := VarToStr(SrcSheet.Cells[R, MaCol].Value);
        if Trim(SetVal) = '' then SetVal := '0';
        if Trim(MaVal)  = '' then MaVal  := '0';
        if Trim(ProcName) <> '' then
          SL.Add(CsvJoin(TArray<string>.Create(MfgNo, PartFig, ProcName, SetVal, MaVal)));
        Inc(Done);
      end;
      if Assigned(AProgress) then AProgress.Position := Done;
    end;

    ForceDirectories(ExtractFileDir(Path));
    SL.SaveToFile(Path, TEncoding.UTF8);
    MemoStep(AMemo, Format('PROCESS completed (%d rows)', [SL.Count - 1]));
  finally
    SL.Free;
  end;
end;

{-------------------- Main --------------------}

procedure ExportSplit(const IniPath: string; AProgress: TProgressBar; AMemo: TMemo = nil);
var
  Ini: TMemIniFile;
  InputFile, SheetName: string;
  OutJob, OutPart, OutProcess, LogPath, LogDir: string;
  Excel, WB, Sheet: OleVariant;
  HeaderJob, HeaderPart: TArray<string>;
begin
  HeaderJob := TArray<string>.Create('CstmrCD','Cstmr.Name','Mfg.No.','RE','ProductName');
  HeaderPart := TArray<string>.Create('ColC','PartsName','Material','SizeRemarks','PartsQuantity');

  MemoStep(AMemo, 'Reading INI...');
  Ini := TMemIniFile.Create(IniPath, TEncoding.UTF8);
  try
    InputFile  := Ini.ReadString('Input', 'File', '');
    SheetName  := Ini.ReadString('Input', 'Sheet', 'Sheet1');
    OutJob     := ForceCsvName(Ini.ReadString('Output1','Path',''), 'NewOrder_Job');
    OutPart    := ForceCsvName(Ini.ReadString('Output2','Path',''), 'NewOrder_Part');
    OutProcess := ForceCsvName(Ini.ReadString('Output3','Path',''), 'NewOrder_Process');

    LogPath := Ini.ReadString('Options', 'LogPath', '');
    if Trim(LogPath) = '' then
    begin
      LogDir := IncludeTrailingPathDelimiter(ExtractFilePath(ParamStr(0))) + 'LOG\';
      if not TDirectory.Exists(LogDir) then
        TDirectory.CreateDirectory(LogDir);
      LogPath := TPath.Combine(LogDir, 'export_log_' + FormatDateTime('yyyymmdd', Now) + '.txt');
    end;
  finally
    Ini.Free;
  end;

  if not FileExists(InputFile) then
    raise Exception.Create('Input file not found: ' + InputFile);

  MemoStep(AMemo, 'Opening Excel...');
  CoInitialize(nil);
  try
    Excel := CreateOleObject('Excel.Application');
    Excel.Visible := False;
    WB := Excel.Workbooks.Open(InputFile);
    try
      try
        Sheet := WB.Worksheets[SheetName];
      except
        Sheet := WB.Worksheets[1];
      end;

      if OutJob <> '' then
        SaveCSVWithCustomHeader(Sheet, COL_JOB_FIRST, COL_JOB_LAST, OutJob, 'JOB', LogPath, AProgress, AMemo, HeaderJob);
      if OutPart <> '' then
        SaveCSVWithCustomHeaderByCols(Sheet, [3,6,7,8,9], OutPart, 'PART', LogPath, AProgress, AMemo, HeaderPart);
      if OutProcess <> '' then
        SaveProcessAsLongCSV(Sheet, OutProcess, LogPath, AProgress, AMemo);

      MemoStep(AMemo, 'Export completed successfully.');
    finally
      WB.Close(False);
      Excel.Quit;
    end;
  finally
    CoUninitialize;
  end;
end;

end.

